<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns="http://www.tei-c.org/ns/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Project Endings staticSearch Generator</title>
        <author><name>Martin Holmes</name></author>
        <author><name>Joey Takeda</name></author>
      </titleStmt>
      <publicationStmt>
        <publisher>University of Victoria Humanities Computing and Media Centre</publisher>
        <availability><licence>Free to anyone for any purpose</licence></availability>
      </publicationStmt>
      <sourceDesc>
        <p>Born-digital document</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <front>
      <titlePage>
        <docTitle>
          <titlePart type="main">Project Endings staticSearch Generator</titlePart>
          <titlePart type="sub">Schema and guidelines for creating a staticSearch engine for your HTML5 site</titlePart>
        </docTitle>
        <docAuthor>Martin Holmes</docAuthor>
        <docAuthor>Joey Takeda</docAuthor>
        <docDate>2019-2023</docDate>
      </titlePage>
      <p>This documentation provides instructions on how to use the Project Endings
        staticSearch Generator to provide a fully-functional search <soCalled>engine</soCalled>
        to your website without any dependency on server-side code such as a database.</p>
      <divGen type="toc"/>
    </front>
    <body>
        <head>Project Endings staticSearch Generator</head>
        <div xml:id="whatDoesItDo">
          <head>What does it do?</head>
          <list>
            <item>Level: Basic</item>
            <item>Last Updated: <date when="2020-10-14">14 October 2020</date></item>
          </list>
          <p>The generator tool processes your site to create an index of all the words appearing
          in the site, stemmed (if desired) using a stemmer, and stores the index in the 
          form of a
          large number of small JSON files. It also creates JSON files for other search facets that 
          you specify in the headers of your documents, to allow searches for documents by 
          type, by date range, and so on. Then it creates a search page for your site, which 
          processes user search terms and retrieves the required JSON files to provide search results.</p>
          <p>You can see several examples of sites and projects which use staticSearch in 
            <ref target="#projectsUsingSS">Projects using staticSearch</ref>.</p>
          
        </div>
      <div xml:id="whyWouldIUseIt">
        <head>Why would I use it?</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-05-08">8 May 2020</date></item>
        </list>
        <p>Digital Humanities projects such as digital editions of historical and literary texts are typically the work of teams of people collaborating over many years, and the fruit of their labours deserves to have a significant shelf-life, if possible comparable with that of a traditional print publication. However, digital longevity of DH projects is sadly short, and many disappear or cease to function within a few years of their creation, because of their dependency on transient tools and technologies.</p> 
        
        <p>However, static websites (websites which consist entirely of HTML, CSS and JavaScript, without any dependency on back-end server systems such as databases or PHP processing) are far more resilient in the long term than sites which use more server-side technology, and are also much easier to archive and replicate (see Holmes and Takeda (2019), <ref target="https://zenodo.org/record/3449197">The Prefabricated Website: Who needs a server anyway?</ref>). For this reason, the <ref target="https://projectendings.github.io/">Project Endings</ref> team have been developing and publicizing strategies for moving digital projects to an all-static publication model. The most problematic component in the all-static approach is search.</p>
        
        <p>Most digital publications take one of two approaches to search: either they have their own back-end database search engine (perhaps Solr or an XML database), or they rely on commercial services such as Google (which may be free, but are still beyond the control of the project team). DH projects need sophisticated options for searching, but typically this requires the use of technologies that may become obsolete or unsupported, or services which may change their terms of use or become unavailable.</p>
        
        <p>staticSearch solves this problem. It provides the capability to build a sophisticated faceted search engine into your website without the need for any back-end services at all (except of course for a web server, which you need anyway).</p>
        
      </div>
      
        <div xml:id="textSearchFeatures">
          <head>Text search features</head>
          <list>
            <item>Level: Intermediate</item>
            <item>Last Updated: <date when="2021-01-26">26 January 2021</date></item>
          </list>
          <p>The Generator supports the following features:</p>
          <list>
            <item>Stemming of terms (so searching for <q>wait</q> will also
            retrieve <q>waiting</q>, <q>waits</q>, <q>waited</q> etc.). Our default stemmer
            is the English Porter 2 stemmer, but there is also a French stemmer, as well as 
            an <soCalled>identity</soCalled> stemmer (which makes no changes) and a diacritic-stripping
              stemmer. If you have documents in another language, you can create
            and plug in <ref target="#stemmerFolder">your own stemmer</ref>.</item>
            <item>Boolean search operators. Adding <code>+</code> (plus) before a word means that
            search results <emph>must contain</emph> that word, and adding a <code>-</code> (minus) means
            that results <emph>must not contain</emph> that word. Words without plus or minus are treated
            as <emph>may contain</emph>, contributing to the score of any retrieved document.</item>
            <item>Phrasal searches. Any quoted phrase will be searched as-is, and when quoted phrases 
            are included in a search, any hit document must contain at least one of them. Note that phrasal
            search support requires a specific setting in your configuration file, because it increases the
            size of the index.</item>
            <item>Keyword-in-context search results. This is also configurable, since including contexts
            increases the size of the index.</item>
            <item>Wildcard searches, using the asterisk (*), question mark (?) and character
            classes ([ab]). So you can search for <code>lo[uv]e?</code> to find <q>loved</q>,
              <q>loued</q>, <q>loves</q>, <q>louer</q>, etc. If you don't have a stemmer for 
            the language of your document collection, this feature is a good alternative (although
            it can be combined with a stemmer as well for greater flexibility).</item>
            <item>Search filtering using any metadata you like, allowing users to limit their 
              search to specific
            document types, date ranges, or other features.</item>
          </list>
        </div>
      <div xml:id="searchFacetFeatures">
        <head>Search facet features</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2021-05-12">12 May 2021</date></item>
        </list>
        <p>The Generator supports the following search facets or filters:</p>
        <list>
          <item><term>Descriptors</term>. You might for example classify your documents as poems, 
          short stories and novels; the user can then choose to search in only poems or in poems and short stories.</item>
          
          <item><term>Date ranges</term>. You might assign each document a date (or a date range) for its first 
          publication and another for its last publication; then users could search for documents first published in a
          certain date range and last published before another date.</item>
          
          <item><term>Number ranges</term>. Similar to date ranges, you can assign a number to
          each document and then filter the search on a subrange of those numbers. For example, 
          a collection of poems might be filtered on the number of stanzas, so users could
          find all two-stanza poems or all poems with three or more stanzas.</item>
          
          <item><term>Booleans</term> (true/false values). You might for instance specify that some poems are 
          illustrated while others are not. The user could then limit their search only to illustrated poems.</item>
          
          <item><term>Features</term>. Features are similar to Descriptors, but are intended for cases where
          there are so many possibly items that having a long list of checkboxes on the page is not practical,
          so instead, a typeahead control is provided, allowing the user to type some characters and get
          a list of matching items. A good use-case might be <soCalled>People mentioned</soCalled> in a
          document collection. There might be thousands of people mentioned, and any given document might
          mention twenty of them. The searcher can type a few letters of a person's name to see a list
          of suggestions, and then add checkboxes for any matching people; those checkboxes will then
          function like Descriptor checkboxes.</item>
          
        </list>
      </div>
      
      <div xml:id="searchPageCaptions">
        <head>Search page captions</head>
        <list>
          <item>Level: Intermediate</item>
          <item>Last Updated: <date when="2021-01-24">24 January 2021</date></item>
        </list>
        <p>Various captions (<q>Searching...</q>, <q>Documents found</q>, <q>Score</q> 
          and so on) are shown during operations in the search page. These captions are
          currently configured in the JavaScript file <ident>ssSearch.js</ident> in the form of
          a JavaScript array which has both English and French captions. The caption 
          language is selected based on the <att>lang</att> attribute on the root 
          <gi>html</gi> element of the search page; if there are no captions configured 
          for the language in the <att>lang</att> attribute, the default English captions
          are used.
        </p>
        <p>If your search page is in a language other than English and French, please 
        contribute to the project by providing captions in that language so that we can
        increase the number of languages supported by the project. When the number of 
        available language caption sets becomes significant, we will abstract them from
        the core JavaScript library and store them in a separate location, inserting them
        into the page at build time instead.</p>
      </div>
      
      <div xml:id="howDoIGetIt">
        <head>How do I get it?</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-01-13">13 January 2020</date></item>
        </list>
        <p>There are two ways to get the staticSearch code. The first is to download a release package from 
          the <ref target="https://github.com/projectEndings/staticSearch/releases/">project release page</ref>;
        we recommend that you get the latest version. You can download a zip file and unzip it to create a 
        folder containing the code.</p>
        <p>The second way to get the codebase is to clone it from the 
          <ref target="https://github.com/projectEndings/staticSearch">GitHub repository</ref>. If you're doing 
        this, you can clone either the current master branch, the last release tag, or the dev branch. If you 
        clone the dev branch, bear in mind that you're working with development code and things may break.</p>
      </div>
        <div xml:id="howDoIUseIt">
          <head>How do I use it?</head>
          <list>
            <item>Level: Intermediate</item>
            <item>Last Updated: <date when="2021-02-26">26 February 2021</date></item>
          </list>
          <p>First, you will have to make sure your site pages are correctly configured so that the Generator can
          parse them. Then, you will have to create a configuration file specifying what options you want to use. 
          Then you run the generator, and the search functionality should be added to your site.</p>
          
            <p>The generator is expecting to parse <emph>well-formed XHTML5 web pages</emph>. That means
            web pages which are well-formed XML, using the XHTML namespace. If your site is just raggedy tag-soup,
            then you can't use this tool. You can tidy up your HTML using 
              <ref target="http://www.html-tidy.org/">HTML Tidy</ref>.</p>
          
          <div xml:id="filters">
            <head>Configuring your site: search filters</head>
            <p>Next, you will need to decide whether you want search filters or not. If you want to allow
            your users to search (for example) only in poems, or only in articles, or only in blog posts, or 
            any combination of these document types, you will need to add <gi>meta</gi> tags to the heads of
            your documents to specify what these filters are. <title level="m">staticSearch</title> supports 
            four filter types.</p>
            
            <div xml:id="descFilters">
              <head>Description filters</head>
              <p>
              The description (desc) filter is a word or phrase describing or associated with the document.
              Here is a simple example:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Document type" class="staticSearch_desc" content="Poems" />
              </egXML>
              
              This specifies that there is to be a descriptive search filter called <q>Document type</q>, and one of the
              types is <q>Poems</q>; the document containing this <gi>meta</gi> tag is one of the Poems. Another
              type might be:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Document type" class="staticSearch_desc" content="Short stories" />
              </egXML>
              
              If the Generator finds such meta tags when it is indexing, it will create a set of filter controls
              on the search page, enabling the user to constrain the search to a specific set of filter settings.
            </p>
              
              <div xml:id="descFilterSorting">
                <head>Sort order for description filters</head>
                
                <p>Description filter labels may be plain text such as <q>Short stories</q> or <q>Poems</q>, but
                they may also be more obscure labels relating to document categories in indexing systems or 
                archival series identifiers. When the search page is generated, these labels are turned into
                a series of labelled checkboxes, sorted in alphabetical order. However, the strict alphabetical order
                of items may not be exactly what you want; you may want to sort <q>305 2</q> before <q>305 10</q>
                for example. To deal with cases like this, in addition to the <att>content</att> attribute, you 
                can also supply a custom <att>data-ssfiltersortkey</att> attribute, providing a sort key for
                each label. Here is are a couple of examples:
                
                  <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <meta name="Archival series" class="staticSearch_desc" data-ssfiltersortkey="305_02" content="305 2" />
                    <meta name="Archival series" class="staticSearch_desc" data-ssfiltersortkey="305_10" content="305 10" />
                  </egXML>
                  
                  In this case, the first item will sort in the filter list before the second item based on the sort 
                  key; without it, they would sort in reverse order based on the <att>content</att> attribute. Note that
                  the <att>data-ssfiltersortkey</att> attribute name is all-lower-case, to comply with the  XHTML5 schema.
                
                </p>
                
              </div>
            </div>
            
            
            <div xml:id="dateFilters">
              <head>Date filters</head>
            <p>Another slightly different kind of search control is a document date. If your collection of 
            documents has items from different dates, you can add a <gi>meta</gi> tag like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Date of publication" class="staticSearch_date" content="1895-01-05" />
              </egXML>
              
              The date may take any of the following forms:
              
              <list>
                <item>1895 (year only)</item>
                <item>1895-01 (year and month)</item>
                <item>1895-01-05 (year, month and day)</item>
              </list>
              
              For some documents, it may not be possible to specify a single date in this form,
              so you can specify a range instead, using a slash to separate the start and end
              dates of the range (following ISO 8601):
              
              <list>
                <item>1895/1897</item>
               <item>1903-01-02/1905-05-31</item>
              </list>
            </p>
            </div>
            
            <div xml:id="numFilters">
              <head>Number filters</head>
            
            <p>You can also configure a range filter based on
            a numeric value (integer or decimal). For example, you might want to allow
            people to filter documents in the search results based on their word-count:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Word-count" class="staticSearch_num" content="2193" />
              </egXML>
              
              Users would then be able to set a minimum and/or maximum word-count when
              searching for documents.
            </p>
            
            </div>
            
            <div xml:id="boolFilters">
              <head>Boolean filters</head>
            
            <p>A fourth filter type is the boolean (true/false) filter. To use boolean filters, add meta tags like this
            to your documents:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Peer-reviewed" class="staticSearch_bool" content="true" />
              </egXML>
            
            </p>
            </div>
            
            <div xml:id="featFilters">
              <head>Feature filters</head>
              <p>
                The feature (feat) filter, just like a description filter, is a word or phrase describing or 
                associated with the document. Here is a simple example:
                
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <meta name="People mentioned" class="staticSearch_feat" content="Nelson Mandela" />
                </egXML>
                
                This specifies that there is to be a feature search filter called <q>People mentioned</q>, and one of the
                possible people is <q>Nelson Mandela</q>. This differs from a description filter in that the number of
                possible people (or other feature) is expected to be large. If there are (for example) three hundred 
                people mentioned in the document collection, then using a description filter would result in three 
                hundred checkboxes in the search page; this is clearly impractical. Instead, for large feature sets
                like this, the feature filter provides a text box into which the user can type some part of the 
                feature they're searching for, and get a drop-down list of matches. Selecting a match creates a 
                checkbox in the search page, which then functions just like a description filter. Here's another example:
                
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <meta name="Postcodes mentioned" class="staticSearch_feat" content="V8W 1P4" />
                </egXML>
                Obviously, a feature filter must be based on data that a searcher will be able to predict. Searchers
                can also search for names or postcodes using the text search facility, of course, but names might 
                appear in different forms in different texts, so a feature filter allows the user to find all instances
                of a particular person using the canonical form of their name.
              </p>
              <p>Note that feature filters have one drawback: they slow down the initialization of the search
              page noticeably. In order to provide the typeahead/drop-down functionality, the JSON for each 
              feature filter will need to be retrieved as the page loads, so if you have many feature filters,
              or particularly large ones, the user may have to wait a few seconds before the page becomes
              fully functional.</p>
            </div>
            
          </div>
          
          <div xml:id="configuringDocTitles">
            <head>Configuring your site: document titles</head>
            
            <p>When the indexing process runs over your document collection, by default it will use the document
            title that it finds in the <gi>title</gi> element in the document header; that title will then be 
            shown as a link to the document when it comes up in search results. However, that may not be the ideal
            title for this purpose; for example, all of your documents may include the site title as the first part
            of their document title, but it would be pointless to include this in the search result links. Therefore
            you can override the document title value by providing another meta tag, like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docTitle" class="staticSearch_docTitle" content="What I did in my holidays" />
              </egXML>
            
            </p>
          </div>
          
          <div xml:id="configuringDocSortKey">
            <head>Configuring your site: document sort keys</head>
            
            <p>When a user searches for text on your site, the documents
              retrieved will be presented in a sequence based on the 
              <soCalled>hit score</soCalled> or <soCalled>relevance
                score</soCalled>; documents with the highest scores will
              be presented first, and the list will be in descending
              order of relevance. However, if you have search filters on
              your site, it is possible that users will not enter any 
              search text at all; they may simply select some filters 
              and get a list of matching documents. In this case, there
              will be no relevance scores, so the documents will be 
              presented in a random order. However, you may wish to 
              control the order in which documents without hit scores, 
              or sequences of documents with the same hit score, are
              presented. You can do this by adding a single meta tag
              to the document providing a <soCalled>sort key</soCalled>,
              which can be used to sort the list of hits. This is an 
              example:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docSortKey" class="staticSearch_docSortKey" content="d_1854-01-02" />
              </egXML>
            </p>
          </div>
          
          <div xml:id="configuringDocThumbnails">
            <head>Configuring your site: document thumbnails</head>
            
            <p>When a document is returned as a result of a search hit, you may want to include with it
            a thumbnail image. This may be for aesthetic reasons, or because the focus of the document
            itself is actually an image (perhaps your site is a set of pages dealing with works of art, for
            instance). Whatever the reason, you can supply a link to a thumbnail image like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docImage" class="staticSearch_docImage" content="images/thisPage.jpg" />
              </egXML>
            
            The <att>content</att> attribute value should either be the path to an image relative to the 
              document itself or the URL to an external image; so in the example above, there would be a folder called <ident>images</ident>
              which is a sibling of the HTML file containing the tag, and that folder would contain a file
              called <ident>thisPage.jpg</ident>.
            
            </p>
            
          </div>
          
          <div xml:id="creatingConfigFile">
            <head>Creating a configuration file</head>
            
            <p>The configuration file is an XML document which tells the Generator where to find your site,
            and what search features you would like to include. The configuration file conforms to a schema which is
            documented here.</p>
            <p>There are three main sections of the configuration file:
              <specList>
                <specDesc key="params"/>
                <specDesc key="rules"/>
                <specDesc key="contexts"/>
              </specList>
              
              Only the <gi>params</gi> element is necessary, but, as we discuss shortly, 
              we highly suggest taking advantage of the <gi>rules</gi>
              (see <ptr target="#specifyingRules"/>) 
              and <gi>contexts</gi> (<ptr target="#specifyingContexts"/>) for the best results.
            </p>
            
            <p>For examples of full configuration files, see the <ref target="https://github.com/projectEndings/staticSearch">staticSearch GitHub repository</ref> as well as the list of projects in <ptr target="#projectsUsingSS"/>, which provides a link to each site’s configuration file.</p>
            
            <div xml:id="rootConfigElement">
              <head>The <gi>config</gi> element</head>
              <p>The configuration element has a root <gi>config</gi> element in the staticSearch namespace (<val>http://hcmc.uvic.ca/ns/staticSearch</val>):
                
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <config xmlns="http://hcmc.uvic.ca/ns/staticSearch">
                    <params>
                      <!--Parameters-->
                    </params>
                    <rules>
                      <!--Rules-->
                    </rules>
                    <contexts>
                      <!--Contexts-->
                    </contexts>
                  </config>
                </egXML>
                
               The <gi>config</gi> element may bear the optional <att>version</att> attribute, which provides the major version number (i.e. a single integer value) of staticSearch that corresponds with the configuration file. 
                
              <specList>
                <specDesc key="config" atts="version"/>
              </specList>
                Though optional, the <att>version</att> attribute is recommended for all configuration files; future version of staticSearch may introduce breaking changes to the structure and syntax of the configuration file, which can be more easily detected by staticSearch when an <att>version</att> is specified.
              </p>
            </div>
            
            
            <div xml:id="specifyingParameters">
              <head>Specifying parameters</head>
              <div xml:id="paramsRequired">
                <head>Required parameters</head>
                <p>The <gi>params</gi> element has four required elements for determining the resource collection that you wish to index:
                  <specList>
                    <specDesc key="searchFile"/>
                    <specDesc key="recurse"/>
                    <specDesc key="stopwordsFile"/>
                    <specDesc key="dictionaryFile"/>
                  </specList>
                </p>
                <p>The <gi>searchFile</gi> element is a relative URI (resolved, like all URIs specified in the config file, against the configuration file location) that points
                  directly to the search page that will be the primary access point for the search. Since the search file must be at the root of the directory that you wish to index
                  (i.e. the directory that contains all of the XHTML you want the search to index), the searchFile parameter provides the necessary information for knowing 
                  what document collection to index and where to put the output JSON. In other words, in specifying the location of your search page, you are also 
                  specifying the location of your document collection. See <ref target="#searchPage">Creating a search page</ref> for more information on how to configure this file.</p>
                <p>Note that all output files will be in a directory that is a sibling to the search page. For instance, in a document collection that looks something like:
                  <list style="font-family: monospace">
                    <item>myProject
                      <list>
                        <item>novel.html</item>
                        <item>poem.html</item>
                        <item>shortstory.html</item>
                        <item>search.html</item>
                      </list>
                    </item>
                  </list>
                  The collection of Javascript and JSON files will be in a directory like so:
                  <list style="font-family: monospace">
                    <item>myProject
                      <list>
                        <item>novel.html</item>
                        <item>poem.html</item>
                        <item>shortstory.html</item>
                        <item>search.html</item>
                        <item><emph>staticSearch</emph></item>
                      </list>
                    </item>
                  </list>
                </p>
                <p>We also require the <gi>recurse</gi> element in the case where the document collection may be nested (as is common with static sites generated from Jekyll or Wordpress). The <gi>recurse</gi> element is a boolean (true or false) that determines whether or not to recurse into the subdirectories of the collection and index those files.</p>
              </div>
              
              <div xml:id="paramsOptional">
                <head>Optional parameters</head>
                <p>The following parameters are optional, but most projects will want to specify 
                some of them:
                <!-- Keep these in separate specLists so that the relevant remarks come
                     directly after each one. -->
                
                  <specList>
                    <specDesc key="versionFile"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="phrasalSearch"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="stemmerFolder"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="scoringAlgorithm"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="createContexts"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="minWordLength"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="maxKwicsToHarvest"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="maxKwicsToShow"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="totalKwicLength"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="kwicTruncateString"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="linkToFragmentId"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="scrollToTextFragment"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="resultsPerPage"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="verbose"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="indentJSON"/>
                  </specList>
                  
                  <specList>
                    <specDesc key="outputFolder"/>
                  </specList>
                  
                </p>
                
              </div>
            </div>
          <div xml:id="specifyingRules">
            <head>Specifying rules (optional)</head>
            <p>
            <specList>
              <specDesc key="rules"/>
              <specDesc key="rule" atts="match weight"/>
            </specList>
            </p>
            <p>The <gi>rules</gi> elements specifies a list of conditions (using the <gi>rule</gi> element) that tell the parser, using XPath statements in the <att>match</att> attribute, specific weights to assign to particular parts of each document. For instance, if you wanted all heading elements (<gi>h1</gi>, <gi>h2</gi>, etc) in documents to be given a greater weight and thus receive a higher score in the results, you can do so using a rule like so:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rules>
                  <rule weight="2" match="h1 | h2 | h3 | h4 | h5 | h6"/>
                </rules>
              </egXML>
              
              Since we're using XPath 3.0 and XSLT 3.0, this can also be simplified to:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rules>
                  <rule weight="2" match="*[matches(local-name(),'^h\d+$')]"/>
                </rules>
              </egXML>
              (It is worth noting, however, the above example is unnecessary: all heading elements are given a weight of 2 by default, which is the only preconfigured weight in staticSearch.)
            </p>
            <p>The value of the <att>match</att> attribute is transformed in a XSLT template match attribute, and thus must follow the same rules (i.e. no complex rules like <code>p/ancestor::div</code>). See the <ref target="https://www.w3.org/TR/xslt-30/#dt-pattern">W3C XSLT Specification</ref> for further details on allowable pattern rules.</p>
            <p>Often, there will be elements that you want the tokenizer to ignore completely; for instance, if you have the same header in every document, then there's no reason to index its contents on every page. These elements can be ignored simply by using a <gi>rule</gi> and setting its weight to 0. For instance, if you want to remove the header and the footer from the search indexing process, you could write something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="footer | header"/>
              </egXML>
              Or if you want to remove XHTML anchor tags (<gi>a</gi>) whose text is identical to the URL specified in its <att>href</att>, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="a[@href=./text()]"/>
              </egXML>
            </p>
            <p>Note that the indexer does not tokenize any content in the <gi>head</gi> of the document (but as noted in <ptr target="#filters"/>, metadata can be configured into filters) and that all elements in the <gi>body</gi> of a document are considered tokenizable. However, common elements that you might want to exclude include:
              <list>
                <item><gi>script</gi></item>
                <item><gi>style</gi></item>
                <item><gi>code</gi></item>
              </list>
            </p>
          </div>
          <div xml:id="specifyingContexts">
            <head>Specifying contexts (optional)</head>
            
            <p>
              <specList>
                <specDesc key="contexts"/>
                <specDesc key="context" atts="match"/>
              </specList>
            </p>
            
            <p>When the staticSearch creates the keywords-in-context strings 
              (the "kwic" or "snippets") for each token, it does so by looking for 
              the nearest block-level element that it can use as its context. Take, 
              for instance, this unordered list:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <ul>
                  <li>Keyword-in-context search results. This is also configurable, since including contexts
                    increases the size of the index.</li>
                  <li>Search filtering using any metadata you like, allowing users to limit their search to specific
                    document types.</li>
                </ul>
              </egXML>
              Each <gi>li</gi> elements is, by default, a <term>context</term> element, meaning that the snippet generated for each token will not extend beyond the <gi>li</gi> element boundaries; in this case, if the <gi>li</gi> was not a context attribute, the term <q>search</q> would produce a context that looks something like:
              
              <eg>"...the size of the index.<hi style="font-weight:bold;">Search</hi> filtering using any metadata you like,..."</eg>
            </p>
            <p>Using the <gi>contexts</gi> element, you can control what elements operate as contexts. For instance, say a page contained a marginal note, encoded as a <gi>span</gi> in your document beside its point of attachment:<note place="foot">This example taken from Thomas S. Kuhn, <title level="m">The Structure of Scientific Revolutions</title> (50th anniversary edition), University of Chicago Press, 2012: p. 191.</note>
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <p>About that program I shall have nothing to say here,<span class="sidenote">Some information on this subject can be found in "Second Thoughts"</span> [...]
                </p>
              </egXML>
              Using CSS, the footnote might be alongside the text of the document in margin, or made into a clickable object using Javascript. However, since the tokenizer is unaware of any server-side processing, it understands the <gi>span</gi> as an inline element and assumes the <gi>p</gi> constitutes the context of the element. A search for <q>information</q> might then return:
              
              <eg>"...nothing to say here,Some <hi style="font-weight:bold;">information</hi> on this subject can be found...</eg>
              
              To tell the tokenizer that the <gi>span</gi> constitutes the context block for any of its tokens, use the <gi>context</gi> element with an <att>match</att> pattern:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <contexts>
                  <context match="span[contains-token(@class,'sidenote')]"/>
                </contexts>
              </egXML>
            </p>
            <p>You can also configure it the other way: if a <gi>div</gi>, which is by default a context block, should not be understood as a context block, then you can tell the parser to not consider it as such using <att>context</att> set to false:
              <egXML xmlns="http://www.tei-c.org/ns/Examples"> 
                <contexts>
                  <context match="div" context="false"/>
                </contexts>
              </egXML>
            </p>
            <p>The default contexts elements are:
              <list>
                <item><gi>body</gi></item>
                <item><gi>div</gi></item>
                <item><gi>blockquote</gi></item>
                <item><gi>p</gi></item>
                <item><gi>li</gi></item>
                <item><gi>section</gi></item>
                <item><gi>article</gi></item>
                <item><gi>nav</gi></item>
                <item><gi>h1</gi></item>
                <item><gi>h2</gi></item>
                <item><gi>h3</gi></item>
                <item><gi>h4</gi></item>
                <item><gi>h5</gi></item>
                <item><gi>h6</gi></item>
                <item><gi>td</gi></item>
              </list>
            </p>
          </div>
            <div xml:id="searchOnlyIn">
              <head>Specifying searchable contexts (<q>search only in</q>)</head>
              <p>Pages may contain different kinds of blocks, or <soCalled>contexts</soCalled>, that need to be differentiated. For example, consider a page for an online journal article, which includes the article’s title, an abstract, the body of the article, and footnotes. Users may want to search for terms only within abstracts or they may want to search only within the body of the article, ignoring editorial and paratextual material.</p>
              <p>The <gi>context</gi> mechanism provides a way to specify particular components of a page that can be searched within using the <att>label</att> attribute.
                <specList>
                  <specDesc key="contexts"/>
                  <specDesc key="context" atts="label"/>
                </specList>
                
            The text in the <att>label</att> serves as the text for a filter option on the generated search page, which allows users to perform a search within only a particular component of the page. For instance, for a page structured like the journal article mentioned above, we could specify the abstract, the notes, and the document’s body like so:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <contexts> 
                    <context match="article[@id='article_content']" label="Article text only"/>
                    <context match="div[contains-token(@class,'footnote')]" label="Notes only"/>
                    <context match="section[@id='abstract']" label="Abstracts only"/>
                    <context match="span[contains-token(@class,'inline-note')]" label="Notes only"/>
                  </contexts>
                </egXML>
               The generated search page will then contain a set of checkboxes derived from the distinct <att>label</att> values. There is no requirement for the <att>label</att> values to be distinct, but any identical labels will be treated as identical contexts (i.e. in the example above, searching for a string within "Notes only" will return all results found within both the div elements with a <att>class</att>="footnote" and the span elements with <att>class</att>="inline-note".) </p>
            </div>
            <div xml:id="specifyingExclusions">
              <head>Specifying exclusions (optional)</head>
              
              <p>
                <specList>
                  <specDesc key="excludes"/>
                  <specDesc key="exclude" atts="type match"/>
                </specList>
              </p>
              
              <p>A complex site may have two or more search pages targetting
              specific types of document or content, each of which may need 
              its own particular search controls and indexes. This can easily 
              be achieved by specifying a different <gi>searchFile</gi> and 
              <gi>outputFolder</gi> in the configuration file for each search.</p>
              
              <p>For these searches to be different from each other, 
              they will also probably have different contexts and rules. For
              example, imagine that you are creating a special search page 
              that focuses only on the text describing images or figures 
              in your documents. You might do it like this:
              
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <rules> 
                    <rule match="text()[not(ancestor::div[@class='figure']or ancestor::title)]" weight="0"/>
                  </rules>
                </egXML>
              
              This specifies that all text nodes which are not part of the document title
              or descendants of <tag>div class="figure"</tag> should be ignored 
                (<att>weight</att>=<val>0</val>), so only your target nodes will be
                indexed.
              </p>
              
              
              <p>However, it's
              also likely that you will want to exclude certain features or 
              documents from a specialized search page, and this is done using
              the <gi>excludes</gi> section and its child <gi>exclude</gi> elements.</p>
              
              <p>Here is an example:
              
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <excludes>
                    <!-- We only index files which have illustrations in them. -->
                    <exclude type="index" 
                      match="html[not(descendant::meta[@name='Has illustration(s)'][@content='true'])]"/>
                    
                    <!-- We ignore the document type filter, 
                         because we are only indexing one type 
                         of document anyway. -->
                    <exclude type="filter" match="meta[@name='Document type']"/>
                    
                    <!-- We exclude the filter that specifies 
                         these documents because it's pointless. -->
                    <exclude type="filter" match="meta[@name='Has illustration(s)']"/>
                  </excludes>
                </egXML>
              
              Here we use <tag>exclude type="index"/</tag> to specify that all documents which do not contain 
                <tag>meta name="Has illustration(s)" content="true"/></tag>
                should be ignored. Then we use two <tag>exclude type="filter"/</tag> tags to 
                specify first that the <ident>Document type</ident> filter should be
                ignored (i.e. it should not appear on the search page), and second, that the 
                boolean filter <ident>Has illustrations(s)</ident> should also be excluded.
              </p>
              
              <p>Using exclusions, you can create multiple specialized search pages which have customized
              form controls within the same document collection. This is at the expense of additional
              disk space and build time, of course; each of these searches needs to be built separately.</p>
              
            </div>
          </div>
          
          <div xml:id="searchPage">
            <head>Creating a search page</head>
            <p>You'll obviously want the search page for your site to conform with the look and 
            feel of the rest of your site. You can create a complete HTML document (which must 
            of course also be well-formed XML, so it can be processed), containing all the site 
            components you need, and then the search build process will insert all the necessary
            components into that file. The only requirement is that the page contains one <gi>div</gi>
            element with the correct <att>id</att> attribute:
            
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <div id="staticSearch"> 
                [...content will be supplied by the build process...] 
              </div>
            </egXML>
              
              This <gi>div</gi> will be empty initially. The build process will find insert the search 
              controls, scripts and results <gi>div</gi> into this container. Then whenever you 
              rebuild the search for your site, the contents
              will be replaced. There is no need to make sure it's empty every time.</p>
              
              <p>The search process will also add a link to the staticSearch CSS file to the <gi>head</gi> of the
              document:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <link rel="stylesheet" href="staticSearch/ssSearch.css" id="ssCss"/>
              </egXML>
              
              You can customize this CSS by providing your own CSS that overrides it, using <gi>style</gi>,
                or <gi>link</gi>, placed after it in the <gi>head</gi> element, or by replacing
              the inserted CSS after the build process. Note that some features, like <gi>resultsPerPage</gi> or
                the <quote>Searching</quote> loading dialog, rely on rules included in the base staticSearch CSS;
                if you do remove or disable the CSS, then some features may not work properly.</p>
            <p>Note that once your file has been processed and all this content has been added,
            you can process it again at any time; there is no need to start every time with a clean,
            empty version of the search page.</p>
            
            <p>You can take a look at the <ident>test/search.html</ident> page for an example
            of how to configure the search page (although note that since this page has already 
            been processed, it has the CSS and the search controls embedded in it; it also has some
            additional JavaScript which we use for testing the search build results, which is not 
            necessary for your site).</p>
            
          </div>
          
          <div xml:id="searchBuildProcess">
            <head>Running the search build process</head>
            <p>Once you have configured your HTML and your configuration file, you're ready to 
            create a search index and a search page for your site. This requires that you run ant
            in the root folder of the staticSearch project that you have downloaded or cloned.</p>
            
            <p>Note: you will need Java and <ref target="https://ant.apache.org/">Apache Ant</ref> installed, 
              as well as <ref target="http://ant-contrib.sourceforge.net/">ant-contrib</ref>. </p>
            
            <p>Before running the search on your own site, you can test that your system is able
            to do the build by doing the (very quick) build of the test materials. If you simply run 
            the <ident>ant</ident> command, like this:</p>
            
            <eg>mholmes@linuxbox:~/Documents/staticSearch$ ant</eg>
            
            <p>you should see a build process proceed using the small test collection of
            documents, and at the end, a results page should open up giving you a report
            on what was done. If this fails, then you'll need to troubleshoot the problem 
            based on any error messages you see. (Do you have Java, Ant and ant-contrib installed and
            working on your system?).</p>
            
            <p>If the test succeeds, you can view the results by uploading the <ident>test</ident>
            folder and all its contents to a web server, or by running a local webserver on your 
            machine in that folder, using the 
              <ref target="https://docs.python.org/3.8/library/http.server.html">Python HTTP server</ref>
              or <ref target="https://www.php.net/manual/en/features.commandline.webserver.php">PHP's built-in web server</ref>.</p>
            
            <p>If the tests all work, then you're ready to build a search for your own site. Now you need
            to run the same command, but this time, tell the build process where to find your custom
            configuration file:<note place="foot">Note that you can use either <ident>ssConfigFile</ident> or <ident>ssConfig</ident> to provide the build with the full path or relative path, respectively, of your configuration file.</note></p>
            
            <eg>ant -DssConfigFile=/home/mholmes/mysite/config_staticSearch.xml</eg>
            
            <p>The same process should run, and if it's successful, you should have a modified <ident>search.html</ident> page
            as well as a lot of index files in JSON format in your site HTML folder. Now you can test your own 
            search in the same ways suggested above.</p>
            
          </div>
          <div xml:id="callingStaticSearchFromAnt">
            <head>Running staticSearch from Ant</head>
            <p>staticSearch can be integrated into existing ant build processes quite easily. Once  cloned (or downloaded) from GitHub, the staticSearch codebase can be called by a build process using the <code>ant</code> target with a nested <gi>property</gi> value that points to your staticSearch config file (either relative to staticSearch using <code>ssConfig</code> or an absolute path using <code>ssConfigFile</code>). Assuming that the build file, your config file, and your staticSearch directory are all at the root of the project, you could call the staticSearch build in ant like so:
          
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <ant antfile="${basedir}/staticSearch" inheritall="false">
                  <property name="ssConfig" value="staticSearch_config.xml"/>
                </ant>
              </egXML>
            </p>
            
            <p>Note that any arguments passed to ant at the command line arguments will be passed on to the staticSearch build. This can cause issues when the main build requires the use of the <code>-lib</code> parameter (since the project's version of Saxon may conflict, for instance, with the version used by staticSearch). If your build requires the use of the <code>-lib</code> parameter, then an alternative approach for calling staticSearch from your build is to use the <code>exec</code> task like so:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <exec executable="ant" dir="staticSearch">
                  <arg value="-DssConfig=../config_staticSearch.xml"/>
                </exec>
              </egXML>

            </p>
          </div>
          
          <div xml:id="theStaticSearchReport">
            <head>Generated report</head>
            <p>After indexing your HTML files, the staticSearch build then generates an HTML report of helpful statistics 
              and diagnostics about your document collection, which can be found in the directory specified by <gi>outputFolder</gi>. 
              We recommend looking at this file regularly, especially if you're encountering unexpected behaviour by the staticSearch
              engine, as it contains information that can often help diagnose issues with configured filters or the HTML document collection
              that, if fixed, can improve staticSearch results.</p>
            <p>By default, the report includes only basic information about the number of
            stem files created, the the filters used, and any problems encountered. However,
            if you run the build process using the additional parameter <ident>ssVerboseReport</ident>:
            
            <eg>ant -DssVerboseReport=true -DssConfigFile=...</eg>
            
            then the report will also include a number of tables that outline some statistics about your 
            project. <emph>However, please note that compiling
            these statistics is very memory-intensive and if your site is large, it may cause the build
            process to run out of memory.</emph>
            </p>
            <p>As of version 1.4, the word frequency table is a separate document and is no longer included as part of the verbose report. Instead, after running a build, you can then build just the word frequency table with the special <ident>concordance</ident> target:
              
              <eg>ant -DssConfigFile=path/to/your/config.xml concordance</eg>
              
             While the chart itself is not necessary for the core functionality of staticSearch, it is particularly useful during the initial development of a project’s search engine; it can be used to create and fine-tune the project-specific stopword list (i.e. if a word appears multiple times in every document, then it probably ought to be a stopword) or, in some cases, to locate potential typos in the document collection. Alongside the HTML chart, the concordance target also provides a (large) JSON file that represents that statistical data used to generate the HTML view. It contains a JSON object that lists each stem, its variants; each variant lists each document and the number of times it appears within that document.</p>
            <p>The concordance target comes with the same warning as above: compiling these statistics is memory-intensive and may cause the build process to run out of memory.</p>
          </div>
          
          <div xml:id="advancedFeatures">
            <head>Advanced features</head>
            
            <div xml:id="customAttributes">
              
              <head>Custom attributes</head>
              
              <p>As described in <ptr target="#paramsOptional"/>, if you set the 
                <gi>linkToFragmentId</gi> parameter to <ident>true</ident>, the 
                search index will link each keyword-in-context extract with the 
                closest element that has an <att>id</att>, so that each keyword-in-context
              string in a search result will point directly to a specific page fragment.
              You can also add your own attributes to any element in your document in 
              order to have those attributes appear on the keyword-in-context (KWIC) result
              string (which is in the form of an HTML <gi>li</gi> element).</p>
              
              <p>Imagine that some of the paragraphs in your documents are special
              in some way. You could add an attribute whose name begins with <ident>data-ss-</ident>
              to each of those paragraphs, like this:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <p data-ss-type="special">This paragraph is special for some reason or other...</p>
                </egXML>
                
                When the staticSearch indexer creates KWIC extracts, it automatically
                harvests any attribute whose name begins with <ident>data-ss-</ident> from 
                the containing element or its ancestors, and adds them to the keyword-in-context
                record in the index. Then when that KWIC string is displayed as
                the result of a search, the attribute will be added to the HTML <gi>li</gi>
                element on the page:
                
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <li data-ss-type="special">[KWIC with marked search hit, link, etc.]</li>
                </egXML>
                
                This means that you can add your own CSS or JavaScript to make that KWIC appear
                distinct from other KWICs which come from non-special paragraphs.
              </p>
              
              <p>You can add as many custom attributes as you like (although bear in mind that 
              they increase the size of the index JSON files slightly and may add to the build time).</p>
              
              <p>One specific custom attribute has built-in handling that you may find useful.
              If you add the attribute <att>data-ss-img</att> with a value that points to 
              an image, that image will be displayed to the left of the KWIC string. For example,
              if you do this:
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <p data-ss-img="images/elephant.png">This paragraph is all about elephants...</p>
                </egXML>
                
                then any KWIC results from that paragraph will show the <ident>elephant.png</ident>
                image to the left of the KWIC text. This can be especially useful if your site 
                contains large documents which are broken into sections, and those sections can be 
                helpfully represented by images; the search results will be easier for the user
                to understand by virtue of the associated images. Image URLs should be relative
                to the location of the search page, not the original source document, since the
                images will be displayed on the search page.
              </p>
              
            </div>
            
            <div xml:id="highlightTargetPage">
              <head>Highlighting search hits on target pages</head>
              
              <p>When you use a conventional search engine which is based on a backend database
              and configured for a specific dynamic website, it is not unusual to find that 
              when you follow a link to a search hit on a target page, the hit will be highlighted
              on that page, because the backend database is able to pre-process it. With staticSearch,
              that's not straightforward, because there is no <soCalled>engine</soCalled> that is
              preprocessing your HTML pages. However, if this is important to you, there is a 
              workaround that you can use. Since staticSearch does not modify your web pages, though,
              the implementation has to be done by you.</p>
              
              <p>By default, when you turn on <gi>linkToFragmentId</gi> in the configuration,
              each keyword-in-context result that shows on the search page will have its
              own specific link to the fragment of the document which contains the hit.
              Those links are also provided with a search string, like this:
              
              <code>https://example.com/egPage.html?ssMark=elephant#animals</code>
                
                This link points to the section of the document which has 
                <att>id</att>=<val>animals</val>, but it also says <q>the hit text
                is the word <mentioned>elephant</mentioned>.</q> Some JavaScript
                that runs on the target page, <ident>egPage.html</ident> (which you control)
                will be able to parse the value of the query parameter <ident>ssMark</ident> 
                in order to find the hit text, and highlight it in some way.
              </p>
              <p>Obviously you can implement this any way you like (or just ignore it), but
              we also supply a small demonstration JavaScript library which implements this
              functionality, called <ident>ssHighlight.js</ident>. This JS file is included
              into the staticSearch output folder (see <gi>outputFolder</gi>) by default, and
              if you include it into the header of your own pages, it will probably do the 
              highlighting without further intervention. If, however, you have lots of 
              existing JavaScript that runs when the page loads, there may be some 
              interference between this library and your own code, so you may have to
              make some adjustments to the code.</p>
              
              <p>Note that another alternative is to use the <gi>scrollToTextFragment</gi>
              feature; this does not require any special JavaScript, but at the time 
              of writing it is supported only on some Chromium-based browsers and is 
              non-standard and somewhat unreliable.</p>
              
            </div>
            
            
          </div>
          
        </div>
      <div xml:id="howDoesItWork">
        <head>How does it work?</head>
        <list>
          <item>Level: Advanced</item>
          <item>Last Updated: <date when="2021-05-12">12 May 2021</date></item>
        </list>
        <div xml:id="buildingTheIndex">
          <head>Building the index</head>
          <p>The tokenizing process first processes your configuration file to create an XSLT file
            with all your settings embedded in it. Next, it processes your document collection using
            those settings. Each document is tokenized, and then a separate JSON file is created for
            each distinct token found; this file contains links to each of the documents which contain
            that token, as well as keyword-in-context strings for the actual tokens. There will most
            likely be thousands of these files, but most of them are quite small. These constitute the
            textual index.</p>
          
          <p>In addition, separate JSON files are created for the list of document titles, and for your 
            stopword list if you have specified one. A single text file is also created containing
            all the unique terms in the collection, used when doing wildcard searches.</p>
          
          <p>Next, if you have specified search facets in your document headers, the processor
            will then create a separate JSON file for each of those search facets, consisting of a list 
            of the document identifiers for all documents which match the filters; so if some of your
            documents are specified as <soCalled>Illustrated</soCalled> and some not (true or false),
            a JSON file will be created for the <soCalled>Illustrated</soCalled> facet, with a list of 
            documents which are true for this facet, and a list of documents which are false.
          </p>
          
          <p>Finally, the template file you have created for the search page on your site will be 
          processed to add the required search controls and JavaScript to make the search work.</p>
        </div>
       
       <div xml:id="theSearchPage">
         <head>The search page</head>
         
         <p>In order to provide fast, responsive search results, the search page must download
         only the information it needs for each specific search. Obviously, if it were to download
         the entire collection of thousands of token files, the process would take forever. So when 
         you search for the word <mentioned>waiting</mentioned>, what happens is that the
         JavaScript stems that word, producing <mentioned>wait</mentioned>, then it downloads
         only the single file containing indexing information for that specific word, which is very 
         rapid. (If you are using a different stemmer, of course, then the token will be stemmed to
         a different output. If you are using the <ident>identity stemmer</ident>, then 
         the token will be unchanged; with the <ident>stripDiacritics</ident> pseudo-stemmer,
           all combining diacritics will be stripped from the search terms, as they are in 
           the corresponding index.)</p>
         
         <p>However, there is some information that is required for all or many searches. To display
           any results, the list of document titles must be downloaded, for example. A user may
         for instance use the search facets only, not searching for a particular word or phrase but just
         wanting a list of all the documents classified as <soCalled>Poems</soCalled>. This requires that
         the JSON file with information about that facet be downloaded. So there is some advantage 
         in having the JavaScript start downloading some of the essential files (titles, stopwords and
         so on) as soon as the page loads, and it also starts downloading the facet files in the
         background.</p>
         
         <p>At the same time, though, we don't want to clog up the connection downloading these files
         when the user may do a simple text search which doesn't depend on them, so these files
         are retrieved using a <soCalled>trickle</soCalled> approach, one at a time. Then if a search is
         initiated, all the files required for that specific search can be downloaded as fast as possible
         overriding the trickle sequence for files that are needed immediately.</p>
         
         <p>One exception to the trickle approach is the case of Feature filters 
           (where a user can select search facets based on a typeahead control).
           Their JSON files be downloaded to the browser before the typeahead control can be 
           functional, so if you have feature facets in your search, you will see an additional
         delay before the search page is responsive.</p>
         
         <p>Once the user has been on the search page for any length of time, all ancillary files will 
         have been retrieved (assuming they weren't already cached by the browser), so the only 
         files required for any search are those for the actual text search terms; the response should
         therefore be even faster for later searches than for early ones.</p>
       </div>
        
        <div xml:id="jsCompilation">
          <head>JavaScript compilation</head>
          <p>The search page created for your website is entirely driven by JavaScript. The
          JavaScript source code can be found in a number of <ident>.js</ident> files inside the repository 
          <ident>js</ident> folder. At build time, these files (with the exception of
            <ref target="#highlightTargetPage"><ident>ssHighlight.js</ident></ref> and 
            <ref target="#jsInitialization"><ident>ssInitialize.js</ident></ref>) are first 
            concatenated into a single large file called <ident>ssSearch-debug.js</ident>. 
            This file is then optimized using the 
            <ref target="https://github.com/google/closure-compiler/">Google Closure Compiler</ref>, 
            to create a smaller file called <ident>ssSearch.js</ident> which should be faster for 
            the browser to download and parse. Both of these output files are provided in your 
            project <gi>outputFolder</gi>; <ident>ssSearch.js</ident> is linked in your search page,
            but if you're having problems and would like to debug with more human-friendly JavaScript,
            you can switch that link to point to <ident>ssSearch-debug.js</ident>. 
          </p>
          <p>We are still experimenting with the options and affordances of the Closure compiler,
          in the interests of finding the best balance between file size and performance. </p>
        </div>
        
        <div xml:id="jsInitialization">
          <head>The JavaScript Initializer file</head>
          <p>When your search page is created, in addition to the main <ident>ssSearch.js</ident> file, 
          an additional tiny JavaScript file, <ident>ssInitialize.js</ident>, is also linked into
          the page. The only purpose of this script is to create a variable for the StaticSearch object
          and to initialize the object, which causes the search functionality to be set up on the page.
          We do this in a separate file so that if you have any specific options or setup functions
          that run on your own site that might conflict with this initialization process, you can 
          easily modify or remove this single file and manage the initialization of the StaticSearch
          object with your own code. In early versions of staticSearch, this code was injected directly
          into a <gi>script</gi> tag within the search page, but since Content Security Policy settings
          increasingly object to inline JavaScript, we have abstracted it into a separate file.</p>
        </div>
      </div>
      <div xml:id="howDoI">
        <head><q>How do I...</q></head>
        <p>Below are some of the most common things you might want to do using staticSearch:</p>
        <table>
          <row>
            <cell>How do I get staticSearch to ignore large chunks of my document?</cell>
            <cell>Any element with a weight of 0 is ignored completely by the indexer, so add a <gi>rule</gi> for the element. So to ignore all elements with the class <val>ignoreThisElement</val>, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="div[contains-token(@class,'ignoreThisElement')"/>
              </egXML></cell>
          </row>
          <row>
            <cell>How do I get staticSearch to ignore small inline bits and <emph>not</emph> have them in the KWIC?</cell>
            <cell>As above, you can use a <gi>rule</gi> with an <att>weight</att>=<val>0</val></cell>
          </row>
          <row>
            <cell>How do I get staticSearch to ignore an element, but retain its text in the KWIC?</cell>
            <cell>Here, you'll want to use the <gi>exclude</gi> function, which excludes the element from indexing, but doesn't remove it from the document itself. So, if you wanted to exclude all keyboard entry items (<gi>xh:kbd</gi>), but still have them in the KWIC, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <exclude match="kbd" type="index"/>
              </egXML>
            </cell>
          </row>
          <row>
            <cell>How can I get staticSearch to show debugging messages?</cell>
            <cell>Switch <gi>verbose</gi> to true in the configuration file:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <config xmlns="http://hcmc.uvic.ca/ns/staticSearch">
                  <params>
                    <!--....-->
                    <verbose>true</verbose>
                    <!--....-->
                  </params>
                  <!--Rules, etc-->
                </config>
              </egXML>
            </cell>
          </row>
          <row>
            <cell>How can I get staticSearch to jump straight to a specific hit in the document from a search result?</cell>
            <cell>The best way to do this is to ensure that <gi>linkToFragmentId</gi> is set to the <val>true</val> and that the
            input HTML contains ids at whatever level you think is most helpful. For instance, if possible, you could give each
            <gi>xhtml:p</gi> element an <att>id</att>, which would mean that each KWIC could be linked to the right paragraph in the input document.</cell>
          </row>
          <row>
            <cell>How can I get staticSearch to highlight the found text in a target document?</cell>
            <cell>There are two approaches to this: you could implement a JavaScript solution as explained in 
            <ref target="#highlightTargetPage">Highlighting search hits on target pages</ref>, or you could turn on the 
            <gi>scrollToFragmentId</gi> experimental feature supported by some Chromium-based browsers. The former requires
            some modification to your site pages to add some JavaScript, while the latter is non-standard and not really reliable or
            consistent.</cell>
          </row>
          <row>
            <cell>How do I prevent staticSearch from encountering out of memory errors?</cell>
            <cell>If you are indexing a very large collection of files, you may need to provide ant with additional memory by configuring the ANT_OPTS system property. To provide ant with 4GB of memory, you could do something like so:
              <eg>export ANT_OPTS="-Xmx4g"; ant -DssConfigFile=/absolute/path/to/your/config.xml</eg>
              How much memory you can and should provide to Ant depends on your particular system and the size of the document collection. See  <ref target="https://ant.apache.org/manual/install.html">Ant's documentation</ref> for some further examples and explanation.</cell>
          </row>
        </table>
      </div>
      
      
      <div xml:id="newSinceVersion1">
        <head>What's new since version 1.0?</head>
        <list>
          <item>Level: Intermediate</item>
          <item>Last Updated: <date when="2023-02-05">5 February 2023</date></item>
        </list>
        
        <div xml:id="newIn1.4.4">
          <head>Changes in version 1.4.4</head>
          <p>Bug fix:</p>
          <list>
            <item>A deprecated JavaScript function, <code>substr()</code>, which was 
            used in one line of code only, has been replaced by <code>substring()</code>.</item>
          </list>
        </div>
        <div xml:id="newIn1.4.3">
        <head>Changes in version 1.4.3</head>
        <p>New feature:</p>
        <list>
          <item>A new method has been added to the <code>StaticSearch</code> class: <code>preProcessSearchString()</code>, which is called from <code>parseSearchQuery()</code>, does nothing as it is defined, but can be overridden by end-users to enable them to do any special processing they might need to do on an input search string. This is sometimes necessary when (for example) specific diacritics are being ignored by the search indexing, but end-users might type them in anyway. The search string is also being unicode-normalized (to NFC) at the beginning of the parsing function.</item>
        </list>
      </div>
        <div xml:id="newIn1.4.2">
          <head>Changes in version 1.4.2</head>
          <p>Bug fix:</p>
          <list>
            <item>A bug which could cause a divide-by-zero error in the JSON generation 
            stage of the build when the target site consisted of fewer than ten documents
            was fixed via a pull request from Norman Walsh. Thanks Norman!</item>
          </list>
        </div>
        <div xml:id="newIn1.4.1">
          <head>Changes in version 1.4.1</head>
          <p>Bug fix:</p>
          <list>
            <item>A minor bug whereby a rare combination of circumstances could lead to document 
            hit scores being reported as concatenated numbers rather than summed numbers has been fixed.</item>
          </list>
        </div>
        <div xml:id="newIn1.4">
          <head>Changes in version 1.4</head>
          <p>Deprecations requiring changes to existing projects:</p>
          <list>
            <item>Filter sort keys must be declared using the all lower-cased data attribute <att>data-ssfiltersortkey</att>. While the documentation in <ptr target="#descFilterSorting"/> correctly specified the attribute's name, the processing code only accepted the camel-case version, which is invalid XHTML5. In 1.4, using <att>data-ssFilterSortKey</att> will result in WARNINGs; in all subsequent versions, using the camel-case attribute name will result in build failures.</item>
          </list>
          <p>New features and enhancements:</p>
          <list>
            <item>A new <ref target="#searchOnlyIn">Search only in</ref> feature has been added. 
              This enables you to specify regions of documents and label them using the 
              <att>label</att> attribute on <gi>context</gi> (per issue <ref target="https://github.com/projectEndings/staticSearch/issues/20">#20</ref>). 
              Users can then check only the regions they would 
            like to get search results from.</item>
            <item>A new <ref target="#featFilters">feature filter</ref> has been added to the collection of search facets.
            This provides an option for cases where the number of items in a description filter
            might be so large that providing a long list of individual checkboxes for all the options
            is not practical. Instead, the feature filter offers a method of finding and selecting 
            items using a typeahead control.</item>
            <item>Search page controls are now <ref target="https://www.w3.org/WAI/WCAG2AA-Conformance">WCAG2</ref>-compliant.</item>
            <item>When you navigate back or forward to a previous search, if any 
            of the filters which were used in that search are hidden inside closed 
            HTML details elements, those elements will be opened.</item>
            <item>A noscript element is now inserted into the search page to handle
            cases where JavaScript is turned off in the user's browser.</item>
            <item>A <soCalled>Loading...</soCalled> splash screen is shown when 
            the search page is initially configuring itself.</item>
            <item>All inline CSS and JavaScript has now been moved to external
            files, to better suit Content Security Policy constraints.</item>
            <item>The staticSearch report has been simplified and no longer produces a concordance of stems by default. The concordance can be built at the command line by calling the <code>concordance</code> target in ant:
            <eg>ant concordance -DssConfig=cfg.xml</eg>
            </item>
            <item>The <att>version</att> attribute has been added to the root <gi>config</gi> element to better future-proof the alignment of configuration files and the staticSearch codebase. See <ptr target="#rootConfigElement"/> for more details.</item>
          </list>
          <p>Bug fixes:</p>
          <list>
            <item>A bug which caused number filters to be ignored when navigating back
            to a previous search has been fixed.</item>
            <item>A bug which caused the tokenizer to assume wordbreaks when encountering
            certain diacritics has been fixed.</item>
          </list>
          <p>All issues and tickets related to version 1.4 can be found on <ref target="https://github.com/projectEndings/staticSearch/issues?q=is%3Aissue+milestone%3A%22Release+1.4%22+" >GitHub</ref>.</p>
        </div>
        
        <div xml:id="newIn1.3">
          <head>Changes in version 1.3</head>
          <p>Note that version 1.2 was withdrawn in favour of version 1.3, so the list below includes
          changes from the original version 1.2 and the current 1.3.</p>
          
          <p>Deprecations requiring changes to existing projects:</p>
          <list>
            <item>All staticSearch classes with periods have been deprecated in favour of underscores as periods in class names
              conflict with the standard "." chaining selector in CSS and JavaScript. (See <ref target="https://github.com/projectEndings/staticSearch/issues/149">issue 149</ref>
              for the full discussion.) <emph>This affects the majority of staticSearch meta classes, which should be changed from <val>staticSearch.</val> to <val>staticSearch_</val>; see the full list below:</emph>
            <table>
              <row role="label">
                <cell>DEPRECATED VALUE</cell>
                <cell>REPLACE WITH</cell>
              </row>
              <row>
                <cell>staticSearch.desc</cell>
                <cell>staticSearch_desc</cell>
              </row>
              <row>
                <cell>staticSearch.bool</cell>
                <cell>staticSearch_bool</cell>
              </row>
              
              <row>
                <cell>staticSearch.num</cell>
                <cell>staticSearch_num</cell>
              </row>
              
              <row>
                <cell>staticSearch.date</cell>
                <cell>staticSearch_date</cell>
              </row>
              
              <row>
                <cell>staticSearch.docTitle</cell>
                <cell>staticSearch_docTitle</cell>
              </row>
              <row>
                <cell>staticSearch.docImage</cell>
                <cell>staticSearch_docImage</cell>
              </row>
              <row>
                <cell>staticSearch.docSortKey</cell>
                <cell>staticSearch_docSortKey</cell>
              </row>
            </table>
           For version 1.3, using the deprecated period syntax will result in WARNINGs; in all subsequent versions, using the period syntax will result in build failures.
            </item>
            <item>The original parameters <val>config</val> and <val>configFile</val>
              have been renamed <val>ssConfig</val> and <val>ssConfigFile</val> to 
              minimize the chances of naming collisions with parameters in other 
              build processes. <emph>IF YOU HAVE SCRIPTED A staticSearch BUILD AS PART
                OF YOUR OWN BUILD PROCESS, YOU WILL NEED TO UPDATE THESE PARAMETER 
                NAMES.</emph></item>
          </list>
          <p>New features and enhancements:</p>
          <list>
            <item>The JavaScript source code has now been split into 
            several distinct source files, and is compiled and optimized
            using the Google Closure Compiler at build time. See 
              <ref target="#jsCompilation">JavaScript compilation</ref> for
            more information.</item>
            <item>Support for French in captions etc. in the search page has
            been improved.</item>
            <item>A French stemmer is now available, as well as a caption set for French search pages.</item>
            <item>Images can now be configured for specific parts of a document, as well 
              as for the whole document, for display alongside KWICs in results. This is
              part of a new extension mechanism using <ref target="#customAttributes">custom attributes</ref>.</item>
            <item>The CSS for the search page inserted by the indexing process is now more easily 
              accessible in a separate file <ident>css/ssSearch.css</ident>, which is linked
              into the search page at build time.</item>
            <item>Links to target documents from keyword-in-context results now include a search
              string parameter that specifies the hit text, so that JavaScript running in the 
              target page can highlight the search hit(s) and scroll to them. See 
              <ref target="#highlightTargetPage">Highlighting search hits on target pages</ref>
              for more information.</item>
            <item>Documentation has been significantly improved with additional explanatory
              remarks for many elements, and the staticSearch build of the documentation now
              includes hit highlighting (the feature described above).</item>
            <item>Only ancestor ids are indexed when <gi>linkToFragmentId</gi> is enabled; formerly, any preceding
              id value was used.</item>
            <item>Results can now optionally be viewed in batches by setting the new <gi>resultsPerPage</gi> configuration
              option.</item>
            <item>The maximum number of results that a search can return has been set to 2000 results
              by default and can be changed using the new <gi>resultsLimit</gi> element. If a search 
              returns a set of results that exceeds this limit, staticSearch does not render the results
              and advises the user to try a more precise search.
            </item>
            <item>The minimum length of a word to be indexed is now configurable, so in 
              unusual circumstances you can now enable searching for 1- or 2-letter words
              using the <gi>minWordLength</gi> parameter.</item>
            <item>The staticSearch report is now discussed in the documentation (see <ptr target="#theStaticSearchReport"/>) and the "Not in Dictionary" and "Foreign Words" reports have been
              improved.</item>
            <item>The filter creation process has been rationalized such that all filter processing happens
              in <code>json.xsl</code>, which has also improved the build performance slightly.</item>
            
          </list>
          
          <p>Bug fixes:</p>
          <list>
            <item>The encoding structure for docImage, docSortKey, and docTitle has been constrained such that each doc* <gi>meta</gi> must include both a 
              <att>name</att> and <att>class</att> value:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docTitle" class="staticSearch_docTitle" content="My custom document title"/>
              </egXML>
            </item>
            <item>Temporary XML files from dictionaries are now removed during the <code>clean</code> step
              of the build process.</item>
            <item>All HTML characters are properly escaped in context snippets.</item>
          </list>
        </div>
        <div xml:id="newIn1.1">
          <head>Changes in version 1.1</head>
          <p>New features and enhancements:</p>
          <list>
            <item>Search results can now be sorted using a 
              <ref target="#configuringDocSortKey">user-supplied sort key</ref>. This is useful
              when searching only with filters (so all documents have the same relevance score) or 
              where many results have the same relevance score.</item>
            <item>Using the new <gi>linkToFragmentId</gi> parameter, keyword-in-context results can now have individual links to nearest ancestor fragment id, so the searcher can go directly to the relevant section of a document.</item>
            <item>The order of parameter elements in the configuration file is no longer fixed. The schema now allows elements to appear in any order.</item>
            <item>We have added a new <ref target="#howDoI">How Do I...</ref> section in the documentation.</item>
            <item>Phrasal searches are now case-sensitive, meaning that you can use a <soCalled>phrasal search</soCalled> to search for proper names, by putting quotation marks around them and making the 
              first letter upper-case.</item>
            <item>Indexing is faster and the size of the index is smaller because we have eliminated
              the upper-case index.</item>
          </list>
          <p>Bug fixes:</p>
          <list>
            <item>URL containing empty search query string caused unwanted page scroll.</item>
            <item>The build process would fail to open the search report when running under very recent 
              versions of Java.</item>
            <item>Punctuation is no longer stripped from phrasal searches, so searching for
              longer phrases including punctuation should be more successful.</item>
          </list>
        </div>
      </div>
      
      <div xml:id="projectsUsingSS">
        <head>Projects using staticSearch</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2022-08-15">15 August 2022</date></item>
        </list>
        <table>
          <row role="label">
            <cell>Name</cell>
            <cell>Search Page(s)</cell>
            <cell>Configuration file(s)</cell>
          </row>
          <row>
            <cell><ref target="https://mapoflondon.uvic.ca">The Map of Early Modern London</ref></cell>
            <cell><ref target="https://mapoflondon.uvic.ca/search.htm">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/london/static/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://winnifredeatonarchive.org">The Winnifred Eaton Archive</ref></cell>
            <cell><ref target="https://winnifredeatonarchive.org/search.html">Search</ref></cell>
            <cell>
              <ref target="https://github.com/winnifredeatonarchive/wea_data/blob/09ae8660007a10e23e80e2f5769aec0bf1f919c6/code/staticSearch/config.xml">Github</ref></cell>
          </row>
          <row>
            <cell><ref target="https://johnkeats.uvic.ca/">Mapping Keat's Progress</ref></cell>
            <cell><ref target="https://johnkeats.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/keats/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://myndir.uvic.ca/">My Norse Digital Image Repository</ref></cell>
            <cell><ref target="https://myndir.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/myndir/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://bcgenesis.uvic.ca/">The Colonial Despatches of BC and Vancouver Island</ref></cell>
            <cell><ref target="https://bcgenesis.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/coldesp/trunk/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <!--<row>
            <cell><ref target="https://scancan.net">The Scandinavian-Canadian Studies Journal</ref></cell>
            <cell><ref target="https://scancan.net/search.htm">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/scancan/config_staticSearch.xml">SVN</ref></cell>
          </row>-->
          <row>
            <cell><ref target="https://graves.uvic.ca/">The Robert Graves Diary</ref></cell>
            <cell><ref target="https://graves.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/graves/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://francotoile.uvic.ca/">Francotoile</ref> ( a digital library of videos and transcripts of French speakers from around the world)</cell>
            <cell><ref target="https://francotoile.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/francotoile/trunk/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://dvpp.uvic.ca">Digital Victorian Periodical Poetry</ref></cell>
            <cell><ref target="https://dvpp.uvic.ca/search.html">Search</ref> (multiple searches with individual pages)</cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/dvpp/">SVN</ref> (multiple configuration files)</cell>
          </row>
          <row>
            <cell><ref target="https://mariage.uvic.ca/">Le mariage sous L'Ancien Régime</ref></cell>
            <cell><ref target="https://mariage.uvic.ca/recherche.html">Recherche</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/mariage/static/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://loi.uvic.ca/archive/">Landscapes of Injustice</ref></cell>
            <cell><ref target="https://loi.uvic.ca/archive/search.html">Search</ref>. The home page is itself a search page; this is a digital archive with multiple staticSearch interfaces.</cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/landscapes/production/">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="http://medievalmideast.org/">Historical Index of the Medieval Middle East</ref></cell>
            <cell>The home page includes a search function which leads to the search page.</cell>
            <cell></cell>
          </row>
          <!--<row>
            <cell>Linked Early Modern Drama Online (forthcoming)</cell>
            <cell/>
            <cell/>
          </row>-->
        </table>
      </div>
      
      
    </body>
    <back>
      <div xml:id="schemaSpec">
        <head>Schema specification and tag documentation</head>
        
        <schemaSpec ident="staticSearch" start="config" ns="http://hcmc.uvic.ca/ns/staticSearch"
          defaultExceptions="http://hcmc.uvic.ca/ns/staticSearch">

          <moduleSpec ident="ss">
            <desc>Module for all of the staticSearch elements.</desc>
          </moduleSpec>

          <elementSpec ident="config" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The root element for the Search Generator configuration file.</gloss>
            <content>
              <elementRef key="params"/>
              <elementRef key="rules" minOccurs="0"/>
              <elementRef key="contexts" minOccurs="0"/>
              <elementRef key="excludes" minOccurs="0"/>
            </content>
            <attList>
              <attDef ident="version" usage="rec">
                <gloss>specifies the major version of staticSearch to which
                  this configuration file corresponds. If this attribute is not used, the configuration file is assumed to have an <att>version</att> value of <val>1</val>.</gloss>
                <datatype>
                  <dataRef name="nonNegativeInteger"/>
                </datatype>
                <defaultVal>1</defaultVal>
                <exemplum>
                  <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <config version="1">
                      <params>
                        <!--Config options-->
                      </params>
                    </config>
                  </egXML>
                </exemplum>
                <remarks>
                  <p>The <att>version</att> attribute only needs to specify the major version of staticSearch with which the configuration file is compatible. While minor versions may introduce new, optional configuration options, backwards-incompatible changes to the config will only occur across major versions (e.g. a configuration file created for staticSearch 1.1 will work with staticSearch 1.4, but is not guaranteed to work with staticSearch 2.0).</p>
                </remarks>
              </attDef>
            </attList>
          </elementSpec>

          <elementSpec ident="params" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>Element containing most of the settings which enable the Generator to
            find the target website content and process it appropriately.</gloss>
            <content>
              <sequence preserveOrder="false">
                <elementRef key="searchFile"/>
                <elementRef key="versionFile" minOccurs="0"/>
                <elementRef key="stemmerFolder" minOccurs="0"/>
                <elementRef key="recurse"/>
                <elementRef key="linkToFragmentId" minOccurs="0"/>
                <elementRef key="minWordLength" minOccurs="0"/>
                <elementRef key="scrollToTextFragment" minOccurs="0"/>
                <elementRef key="scoringAlgorithm" minOccurs="0"/>
                <elementRef key="phrasalSearch" minOccurs="0"/>
                <elementRef key="wildcardSearch" minOccurs="0"/>
                <elementRef key="createContexts" minOccurs="0"/>
                <elementRef key="maxKwicsToHarvest" minOccurs="0"/>
                <elementRef key="maxKwicsToShow" minOccurs="0"/>
                <elementRef key="totalKwicLength" minOccurs="0"/>
                <elementRef key="kwicTruncateString" minOccurs="0"/>
                <elementRef key="verbose" minOccurs="0"/>
                <elementRef key="stopwordsFile"/>
                <elementRef key="dictionaryFile"/>
                <elementRef key="indentJSON" minOccurs="0"/>
                <elementRef key="outputFolder" minOccurs="0"/>
                <elementRef key="resultsPerPage" minOccurs="0"/>
                <elementRef key="resultsLimit" minOccurs="0"/>
              </sequence>
            </content>
          </elementSpec>

          <elementSpec ident="rules" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of rules that control weighting of search terms
              found in specific contexts.</gloss>
            <content>
              <elementRef key="rule" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="rule" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>A rule that specifies a document path as XPath in the 
              <att>match</att> attribute, and provides weighting for search
              terms found in that context.</gloss>
            <classes>
              <memberOf key="att.match"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="weight" usage="req">
                <gloss>The weighting to give to a search token found in the context specified by the
                  <att>match</att> attribute. Set to 0 to completely suppress indexing for a
                  specific context, or greater than 1 to give stronger weighting.</gloss>
                <datatype>
                  <dataRef name="nonNegativeInteger"/>
                </datatype>
              </attDef>
            </attList>
            <remarks>
              <p>The rule element is used to identify nodes in the XHTML document collection which should be
            treated in a special manner when indexed; either they might be ignored (if <att>weight</att>=<val>0</val>),
            or any words found in them might be given greater weight than words in normal contexts 
              <att>weight</att>&gt;<val>1</val>. Words appearing in headings or titles, for example, might
            be weighted more heavily, while navigation menus, banners, or footers might be ignored completely.</p>
            </remarks>
          </elementSpec>

          <elementSpec ident="contexts" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of <gi>context</gi> elements that identify
            contexts for keyword-in-context fragments.</gloss>
            <content>
              <elementRef key="context" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>

          <elementSpec ident="context" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>A context definition, providing a <att>match</att> attribute that identifies the context,
              allowing keyword-in-context fragments to be bounded by a specific context.</gloss>
            <classes>
              <memberOf key="att.match"/>
              <memberOf key="att.labelled"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="context" usage="opt">
                <datatype>
                  <dataRef name="boolean"/>
                </datatype>
               </attDef>
            </attList>
            <remarks>
              <p>When the indexer is extracting keyword-in-context strings for each word, it uses a common-sense
              approach based on common element definitions, so that for example when it reaches the end of a paragraph,
              it will not continue into the next paragraph to get more context words. You may have special runs of 
            text in your document collection which do not appear to be bounding contexts, but actually are; for 
            example, you may have span elements with <att>class</att>=<val>note</val> that appear in the middle
            of sentences but are not actually part of them. Use <gi>context</gi> elements to identify these 
            special contexts so that the indexer knows the right boundaries from which to retrieve its 
            keyword-in-context strings.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="excludes" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of exclusions, expressed as <gi>exclude</gi> elements, that control the subset of documents
            or filters used for a particular search.</gloss>
            <content>
              <elementRef key="exclude" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="exclude" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>An exclusion definition, which excludes either documents or filters 
              as defined by an XPath in the <att>match</att> attribute.</gloss>
            <classes>
              <memberOf key="att.match"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="type" usage="req">
                <valList type="closed">
                  <valItem ident="index">
                    <gloss>Index exclusion</gloss>
                    <desc>An exclusion that specifies HTML fragment (which itself can be the root HTML element) to exclude from the document index.</desc>
                  </valItem>
                  <valItem ident="filter">
                    <gloss>Filter exclusion</gloss>
                    <desc>An exclusion that matches an HTML meta tag to exclude from the filter controls on the search page.</desc>
                  </valItem>
                </valList>
              </attDef>
            </attList>
            <remarks>
              <p><gi>exclude</gi> can be used to identify documents or parts of documents that are to be omitted from 
              indexing, but, unlike setting <gi>weight</gi> to zero, should be retained during the indexing process. This is helpful in cases where the text itself should be ignored by the indexer, but should still appear in KWICs. Another common use is for multiple search engines/pages that each have their own special features; in this case, you may want one specific search index/page to ignore filter controls (HTML <gi>meta</gi> elements, as 
            described in <ptr target="#searchFacetFeatures"/>) which are provided to support other search pages.</p>
            </remarks>
          </elementSpec>

          <classSpec ident="att.match" module="ss" type="atts">
            <gloss>A class providing attributes that enable specification of document locations.</gloss>
            <attList>
              <attDef usage="req" ident="match">
                <gloss>An XPath equivalent to the @match attribute of an xsl:template, which
                  specifies a context in a document.</gloss>
                <datatype>
                  <dataRef name="string"/>
                </datatype>
              </attDef>
            </attList>
          </classSpec>
          
          <classSpec ident="att.labelled" module="ss" type="atts">
            <gloss>A class providing a label attribute that can be used to identify/describe contexts.</gloss>
            <attList>
              <attDef ident="label" usage="opt">
                <gloss>A string identifier specifying the name for a given context.</gloss>
                <datatype>
                  <dataRef name="string"/>
                </datatype>
                <remarks>
                  <p>When describing a <gi>context</gi>, the <att>label</att> attribute names a component of the page that
                    can be searched within (see <ptr target="#searchOnlyIn"/>).</p>
                </remarks>
              </attDef>
            </attList>
          </classSpec>

          <elementSpec ident="searchFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The search file (aka page) that will be the primary access point for the staticSearch. Note
            that this page <emph>must</emph> be at the root of the collection directory.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
            <remarks>
              <p>The search page is a regular HTML page which forms part of your site. The only 
            important characteristic it must have is a <gi>div</gi> element with 
              <att>id</att>=<val>staticSearch</val>, whose contents will be rewritten by 
            the staticSearch build process. See <ptr target="#searchPage"/>.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="versionFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The relative path to a text file containing a single version identifier (such as 
              <val>1.5</val>, <val>123456</val>, or <val>06ad419</val>). This will be used to create
            unique filenames for JSON resources, so that the browser
            will not use cached versions of older index files.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
            <remarks>
              <p><gi>versionFile</gi> enables you to specify the path to a plain-text file
                containing a simple version number for the project. This might take the form of 
                a software-release-style version number such as <val>1.5</val>, or it might be
                a Subversion revision number or a Git commit hash. It should not contain any 
                spaces or punctuation. If you provide a version file, the version string will
                be used as part of the filenames for all the JSON resources created for the 
                search. This is useful because it allows the browser to cache such resources 
                when users repeatedly visit the search page, but if the project is rebuilt with 
                a new version, those cached files will not be used because the new version will
                have different filenames. The path specified is relative to the location of the
                configuration file (or absolute, if you wish).</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="stemmerFolder" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The name of a folder inside the staticSearch <code>/stemmers/</code> folder, 
              in which the JavaScript and XSLT implementations
            of stemmers can be found. If left blank, then the staticSearch default English 
            stemmer (<code>en</code>) will be used.</gloss>
            <content>
              <dataRef name="NCName"/>
            </content>
            <remarks>
              <p>The staticSearch project currently has only two real stemmers:
                an implementation of the Porter 2 algorithm for modern English, and
                an implementation of the French Snowball stemmer. These 
                appear in the <ident>/stemmers/en/</ident> and <ident>/stemmers/fr/</ident> 
                folders. The default value for this parameter is <val>en</val>; to 
                use the French stemmer, use <val>fr</val>. We will
                be adding more stemmers as the project develops. However, if your 
                document collection is not English or French, you have a couple of options, one 
                hard and one easy.
                
                <list>
                  <item><emph>Hard option</emph>: implement your own stemmers. You will need to
                    write two implementations of the stemmer algorithm, one in XSLT (which 
                    must be named <ident>ssStemmer.xsl</ident>) and one in JavaScript
                    (<ident>ssStemmer.js</ident>), and confirm that they both generate the
                    same results. The XSLT stemmer is used in the generation of the 
                    index files at build time, and the JavaScript version is used to 
                    stem the user's input in the search page. You can look at the 
                    existing implementations in the <ident>/stemmers/en/</ident> folder
                    to see how the stemmers need to be constructed. Place your stemmers
                    in a folder called <ident>/stemmers/[yourlang]/</ident>, and 
                    specify <val>yourlang</val> in the configuration file.
                  </item>
                  <item><emph>Easy option</emph>: Use the <ident>identity stemmer</ident>
                    (which is equivalent to turning off stemming completely), and 
                    make sure wildcard searching is turned on. Then your users can 
                    search using wildcards instead of having their search terms 
                    automatically stemmed. To do this, specify the value <val>identity</val>
                    in your configuration file.
                  </item>
                </list>
                Another alternative is the <ident>stripDiacritics</ident> stemmer. Like the
                <ident>identity stemmer</ident>, this is not really a stemmer at all; 
                what it does is to 
                strip out all combining diacritics from tokens. This is a useful approach
                if you document collection contains texts with accents and diacritics, but 
                your users may be unfamiliar with the use of diacritics and will want to
                search just with plain unaccented characters. For example, if a text contains
                the word <mentioned>élève</mentioned>, but you would like searchers to be able to
                find the word simply by typing the ascii string <mentioned>eleve</mentioned>, then this
                is a good option. Combined with wildcards, it can provide a very flexible and
                user-friendly search engine in the absence of a sophisticated stemmer, or for
                cases where there are mixed languages so a single stemmer will not do. To 
                use this option, specify the value <val>stripDiacritics</val>
                in your configuration file.
              </p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="scoringAlgorithm" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The scoring algorithm to use for ranking keyword results. Default is "raw" (i.e. weighted counts)</gloss>
            <content>
              <valList type="closed">
                <valItem ident="raw">
                  <desc>raw score</desc>
                  <gloss>Default: Calculate the score based off of the weighted number of 
                    instances of a term in a text.</gloss>
                </valItem>
                <valItem ident="tf-idf">
                  <gloss>Calculate the score based off of the tf-idf scoring algorithm.</gloss>
                </valItem>
              </valList>
            </content>
            <remarks>
              <p>
              <gi>scoringAlgorithm</gi> is an optional element that specifies which 
              scoring algorithm to use when calculating the score of a term and thus the order
              in which the results from a search are sorted. There are currently two options:
              <list>
                <item><val>raw</val>: This is the default option (and so does not need 
                  to be set explicitly). The raw score is simply the sum of all instances of a term 
                  (optionally multipled by a configured weight via the
                  <gi>rule</gi>/<att>weight</att> <ref target="#specifyingRules">configuration</ref>) in a document. This will usually provide good
                  results for most document collections.</item>
                <item><val>tf-idf</val>: The tf-idf algorithm (term frequency-inverse document frequency)
                  computes the mathematical relevance of a term within a document relative to the rest
                  of the document collection. The staticSearch implementation of tf-idf basically follows the textbook definition of tf-idf:
                  <formula style="display:block;">
                    tf-idf = ($instancesOfTerm / $totalTermsInDoc) * log( $allDocumentsCount / $docsWithThisTermCount )
                  </formula>
                  This is fairly crude compared to other search engines, like 
                  <ref target="https://lucene.apache.org/core/3_5_0/scoring.html">Lucene</ref>, but it may provide useful results
                  for document collections of varying lengths or in instances where the raw score may be
                  insufficient or misleading. There are a number of resources on tf-idf
                  scoring, including: <ref target="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">Wikipedia</ref> and 
                  Christopher D. Manning, Prabhakar Raghavan and Hinrich Schütze, <ref target="https://nlp.stanford.edu/IR-book/html/htmledition/tf-idf-weighting-1.html">Introduction 
                    to Information Retrieval</ref>, Cambridge University Press. 2008.</item>
              </list>
              </p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="recurse" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to recurse into subdirectories of the collection directory or
              not.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
      
          <elementSpec ident="createContexts" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to include keyword-in-context extracts in the index.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>
                <gi>createContexts</gi> is a boolean parameter that specifies whether you 
                want the indexer to store keyword-in-context extracts for each of the hits in a
                document. This increases the size of the index, but of course it makes for much 
                more user-friendly search results; instead of seeing just a score for each 
                document found, the user will see a series of short text strings with the 
                search keyword(s) highlighted.
              </p>
              <p>Note that contexts are necessary for phrasal searching or wildcard searching.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="minWordLength" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The minimum length of a term to be indexed. Default is 3 characters.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p><gi>minWordLength</gi> specifies the minimum length in 
              characters of a sequence of text that will be considered to
              be a word worth indexing. The default is 3, on the basis that
              in most European languages, words of one or two letters are 
              typically not worth indexing, being articles, prepositions
              and so on. If you set this to a lower limit for reasons specific
              to your project, you should ensure that your stopword list excludes
              any very common words that would otherwise make the indexing 
              process lengthy and increase the index size.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="linkToFragmentId" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to link keyword-in-context extracts to the nearest id in the document. Default is true.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p><gi>linkToFragmentId</gi> is a boolean parameter that specifies whether you want
                the search engine to link each keyword-in-context extract with the closest element that 
                has an <att>id</att>. If the element has an ancestor with an <att>id</att>, then the indexer will associate
                that keyword-in-context extract with that <att>id</att>; if there are no suitable ancestor elements that have
                an <att>id</att>, then the extract is associated with first preceding element with an <att>id</att>.</p>
              <p>We strongly recommend that you ensure your target documents have id attributes for any significant divisions
              so that this parameter can be used effectively. With lots of ids throughout your documents, and this parameter
              turned on, each keyword-in-context in the results page will be linked directly to the section of the 
              document in which the hit appears, making the search results much more useful.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="scrollToTextFragment" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>WARNING: Experimental technology. This turns on a feature currently only 
            supported by a subset of browsers, enabling links from keyword-in-context results
            directly to the specific text string in the target document.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>Google has proposed a browser feature called 
                <ref target="https://wicg.github.io/scroll-to-text-fragment/">Text Fragments</ref>, which would support 
                a special kind of link that targets a specific string of text inside a page.
                When clicking on such a link, the browser would scroll to, and then highlight,
                the target text. This has been implemented in Chrome-based browsers (Chrome, 
                Chromium and Edge) at the time of writing, but other browser producers are sceptical
                with regard to the specification and worried about possible security implications.
                The specification is subject to radical change. <gi>scrollToTextFragment</gi> is a 
                boolean parameter that specifies whether you want to turn on this feature for 
                browsers that support it. It depends on the availability of keyword-in-context 
                strings, so <gi>createContexts</gi> must also be turned on to make it work. The
                feature is automatically suppressed for browsers which do not support it. We recommend 
                only using this feature on sites which are in steady development, so that if 
                necessary it can be turned off, our the staticSearch implementation can be 
                updated to take account of changes. For sites intended to remain unchanged or
                archived for any length of time, this feature should be left turned off. It is
                off by default. A more reliable alternative is probably to use JavaScript to 
                <ref target="#highlightTargetPage">highlight hits on the target page</ref>.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="totalKwicLength" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>If <gi>createContexts</gi> is set to true, then this parameter controls the length (in words) of
              the harvested keyword-in-context string.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p>Obviously, the longer the keyword-in-context strings are, the larger the individual index
                files will be, but the more useful the KWICs will be for users looking at the search results.
              Note that the phrasal searching relies on the KWICs and thus longer KWICs allow for longer
              phrasal searches.</p>
            </remarks>
          </elementSpec>
          
          
          <elementSpec ident="maxKwicsToHarvest" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>This controls the maximum number of keyword-in-context extracts that will be
              stored for each term in a document.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p><gi>maxKwicsToHarvest</gi> controls the number of keyword-in-context extracts
                that will be harvested from the data for each term in a document. For example, if a user
                searches for the word <q>elephant</q>, and it occurs 27 times in a document, but the 
                <gi>maxKwicsToHarvest</gi> value is set to 5, then only the first five (sorted in document order) of these 
                keyword-in-context strings will be stored in the index. (This does not affect the 
                score of the document in the search results, of course.) If you set this to
                a low number, the size of the JSON files will be constrained, but of course the 
                user will only be able to see the KWICs that have been harvested in their search results.</p>
              <p>If <gi>phrasalSearch</gi> is set to true, the <gi>maxKwicsToHarvest</gi> setting is
                ignored, because phrasal searches will only work properly if all contexts are
                stored.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="maxKwicsToShow" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>This controls the maximum number of keyword-in-context extracts that will be shown
              in the search page for each hit document returned.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p>A user may search for multiple common words, so hundreds of hits could be found in 
              a single document. If the keyword-in-context strings for all these hits are shown on
              the results page, it would be too long and too difficult to navigate. This setting 
              controls how many of those hits you want to show for each document in the result set.</p>
            </remarks>
          </elementSpec>

          <elementSpec ident="kwicTruncateString" module="ss"
            ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The string that will be used to signal ellipsis at the beginning and end of a
              keyword-in-context extract. Conventionally three periods, or an ellipsis
              character (which is the default value).</gloss>
            <content>
              <textNode/>
            </content>
            <remarks>
              <p>The only reason you might need to specify a value for this parameter is
            if the language of your search page conventionally uses a different ellipsis
            character. Japanese, for example, uses the 3-dot-leader character.</p>
            </remarks>
          </elementSpec>

          <elementSpec ident="indentJSON" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to indent code in the JSON index files. Indenting increases the
              file size, but it can be useful if you need to read the files for debugging
              purposes.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>Normally, the JSON index files will only be processed by JavaScript, so
            there is no need to indent them, but if you are debugging or investigating how
            the code works, you may find it useful to generate them in a more human-readable
            layout.</p>
            </remarks>
          </elementSpec>
          
          
          <elementSpec ident="phrasalSearch" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to support phrasal searches. If this is true, then the <gi>maxContexts</gi>
            setting will be ignored, because all contexts are required to properly support phrasal search.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>Phrasal search functionality enables your users to search for specific phrases
                by surrounding them with quotation marks (<code>"</code>), as in many search engines. In order 
                to support this kind of search, <gi>createContexts</gi> must also be set to true as we store contexts for all 
                hits for each token in each document. Turning this on will make the index larger, because all 
                contexts must be stored, but once the index is built, it has very little 
                impact on the speed of searches, so we recommend turning this on. The 
                default value is true.</p>
              <p>However, if your site is very large and your user base is unlikely to 
                use phrasal searching, it may not be worth the additional build time and
                increased index size.</p>
            </remarks>
          </elementSpec>
          
          
          <elementSpec ident="wildcardSearch" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to support wildcard searches. Note that wildcard searches are
            more effective when phrasal searching is also turned on, because the contexts 
            available for phrasal searches are also used to provide wildcard results.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>Wildcard searching can coexist with stemmed searching, but it is especially 
            useful when stemming is not available, either because there is no available stemmer
            for the language of the site, or because the site contains multiple languages.
            Unless your site is particularly large, we recommend turning on wildcard searching,
            and therefore also phrasal searching (<gi>phrasalSearch</gi>).</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="resultsPerPage" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The maximum number of document results to be displayed per <soCalled>page</soCalled>. All results
            are displayed by default; setting <gi>resultsPerPage</gi> to a positive integer creates a 
              <soCalled>Show More/Show All</soCalled> widget at the bottom of the batch of results.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p>For most sites, where the number of results is likely to be in the low thousands,
            it's perfectly practical to show all the results at once, because the staticSearch
            processor is so fast. However, if you have tens of thousands of documents, and it's
            possible that users will do (for example) filter-only searches that retrieve a
            large proportion of them, you can constrain the number of results which are shown
            initially using this setting. All the results are still generated and output to 
            the page, but since most of them are hidden until the <soCalled>Show More</soCalled> 
              or <soCalled>Show All</soCalled> button is clicked, the browser will render them
            much more quickly.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="resultsLimit" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The maximum number of results that can be returned for any search before returning an error; if the number
              of documents in a result set exceeds this number, then staticSearch will not render the results and will provide a message
              saying that the search returned too many results. This is usually set to 2000 by default, but you may want to have a higher or lower limit,
            depending on the specific structure of your project.  </gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
            <remarks>
              <p>This configuration option is meant to prevent errors for sites where a given set of filters or search terms
              can return a set of document that can cause a browser's rendering engine to fail. For smaller collections, it's unlikely
              that this limit would ever be reached, but setting a limit may be helpful for large document collections, projects that want to constrain the number
              of possible results, or projects with memory-intensive or complex rendering.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="verbose" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Turns on more detailed reporting during the indexing process.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
            <remarks>
              <p>The staticSearch build process can be lengthy, and if something goes
            wrong it can be difficult to figure out where the problem was. If you're
            having build problems, turn on verbose messages in the configuration file 
            to help with debugging, and you'll see a lot more output at the command line.</p>
            </remarks>
          </elementSpec>
          
          <elementSpec ident="stopwordsFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The relative path (from the config file) to a text file containing a list of 
              stopwords (words to be ignored when indexing). </gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
            <remarks>
              <p>A stopword is a word that will not be indexed, because it is too
                common (<mentioned>the</mentioned>, <mentioned>a</mentioned>, <mentioned>you</mentioned>
                and so on). There are common stopwords files for most languages available on the Web, but 
                it is probably a good idea to take one of these and customize it for your project, since
                there will be words in the website which are so common that it makes no sense to index
                them, but they are not ordinary stopwords. For example, in a Website dedicated to the
                work of John Keats, the name <mentioned>keats</mentioned> should probably be added
                to the stopwords file, since almost every page will include it, and searching for it
                will be pointless. The project has a built-in set of common stopwords for English, which 
                you'll find in <ident>xsl/english_stopwords.txt</ident>. One way to find appropriate stopwords
                for your site is to generate your index, then search for the largest JSON index files that are 
                generated, to see if they might be too common to be useful as search terms. You can also use the
                <title>Word Frequency</title> table in the generated staticSearch report (see <ptr target="#theStaticSearchReport"/>).</p>
              <p></p>
            </remarks>
          </elementSpec>
          <elementSpec ident="dictionaryFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The relative path (from the config file) to a dictionary file (one word per line) which will be used to check
            tokens when indexing.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
            <remarks>
              <p>The indexing process checks each word as it builds the index, and keeps a record
            of all words which are not found in the configured dictionary. Though this does not have
            any direct effect in the indexing process, all words not found in the dictionary are listed
            in the staticSearch report (see <ptr target="#theStaticSearchReport"/>). This can be very useful: 
                all words listed are either foreign (not part of the language of the dictionary) or perhaps 
            misspelled (in which case they may not be correctly stemmed and index, and should be 
            corrected). There is a default  dictionary in <ident>xsl/english_words.txt</ident> which 
                you might copy and adapt if you're working in English; lots of dictionaries for other
                languages are available on the Web.</p>
            </remarks>
          </elementSpec>
          <elementSpec ident="outputFolder" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The name of the output folder into which the index data and JavaScript will 
              be placed in the site search. This should conform with the 
              <ref target="https://www.w3.org/TR/REC-xml/#dt-name">XML Name</ref> specification.</gloss>
            <content>
              <dataRef name="NCName"/>
            </content>
            <remarks>
              <p>When the staticSearch build process creates its output, many files need to be 
            added to the website for which an index is being created. For convenience, all of 
            these files are stored in a single folder. This element is used to specify the 
            name of that folder. The default is <val>staticSearch</val>,
                but if you would prefer something else, you can specify it here. You may also use this element 
                if you are defining two different searches within the same site, so that their files are kept in 
                different locations.</p>
            </remarks>
          </elementSpec>
        </schemaSpec>
      </div>
    </back>
  </text>
</TEI>
